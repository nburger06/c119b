# toy model script
# implementing model for:
# t = 20 years
# n x m = 25 x 25 pixels = 125 pixels = 3750 m2

# states
# 1 = Undisturbed
# 2 = Degraded
# 3 = Deforested
# 4 = Regrown


############################################################
#### Dependencies and directory setup ####
#
#
library(terra)
library(glue)

setwd("C:/Users/nburg/Documents/c119b/c119b/toymodel")


############################################################
#### Set parameters ####
#
#
tf <- 20 # total number of timesteps
n <- 10 # map height. set to 10 to run fast while editing. 
m <- 10 # map width

h0 <- 157 # initial human population of congo basin in millions. based on WWF which is based on CIA data sob. we can find better estimates later.
hpg <- 0.02 # human population growth rate. GENERATED BY COPILOT based on World Bank data for DRC, which is the largest country in the basin and has the most deforestation. ok this number was gend by copilot
kappa <- (1.5 / 74) # this is the climate change constant. calculated as:
# 1.5 degrees C warming between 2026 and 2100, / 74 years to estimate per-year
# linear change. this corresponds to the Intermediate (SSP2-4.5) scenario, total of 2.7 degrees warming
# since pre-industrial levels. 
alpha_h <- 0.5 # human deforestation impact constant
alpha_c <- 0.05 # climate change deforestation impact constant
beta_h <- 0.2 # human degradation impact constant
beta_c <- 0.1 # climate change degradation impact constant
gamma_h <- 0.1 # human secondary deforestation impact constant
gamma_c <- 0.005 # climate change secondary deforestation impact constant
psi_h <- 0.2 # human regrowth impact constant
# gonna consolidate regrowth into one param for now.

#####################################################################
#### Intialize variables ####
#
#



# initialize forest raster and set initial states
r0 <- rast(nrows = n, ncols = m) #10x10 empty raster
crs(r0) <- "local" # explicitly set non-geographic CRS to avoid bleeding between edges (otherwise terra assumes the edges wrap around and form a "globe")
values(r0) <- sample(1, ncell(r0), replace = TRUE) #fill raster w all undisturbed forest
r0[1] <- 3 #start with one deforested cell in the top left corner

levels(r0) <- data.frame( # this MUST be called AFTER setting all the raster values. raster metadata gets stripped when setting new values
  ID = 1:4,
  State = c("Undisturbed", "Degraded", "Deforested", "Regrown")
)

# i think these probabilities can be thought of as "natural" transitions between states without human/climate impact? might be wrong
P <- matrix( #row = current state, col = next state
  c( # U  G     F     R (to)
    1,    0,    0,    0,   # U (from)
    0,    0.95, 0.01, 0.04,   # G
    0,    0.01, 0.99, 0,   # F         # 0 prob of going from F -> R bc it needs to go back to G first? thoughts?
    0,    0.09, 0.01, 0.95    # R 
  ),
  nrow = 4,
  byrow = TRUE
)

w <- matrix(1, 3, 3) #create a 3x3 neighborhood weight matrix
w[2, 2] <- 0



##############################################################
#### Define funcs ####
#
#
neighbor_frac <- function(r, state) {
  # Count matching neighbors
  n_match <- focal(r == state, w, sum, na.rm = TRUE, pad = TRUE, fillvalue = NA)
  # Count total existing neighbors (not NA)
  n_total <- focal(!is.na(r), w, sum, na.rm = TRUE, pad = TRUE)
  
  return(n_match / n_total)
}

modify_P <- function(P, u_frac, g_frac, f_frac, r_frac, alpha, beta, gamma, psi) { #update p matrix based on spatial fracs and time-dependent params
  P2 <- P
  #P2[3, 3] <- P2[3, 3] + 0.3 * f_frac #3,3 is prob of going from F to F. increases depending on f_frac
  P2[1,3]  <- P2[1, 3] + alpha * (f_frac + g_frac) #1,3 is prob of going from U to F. increases depending on f_frac
  P2[1, 2] <- P2[1, 2] + beta * (g_frac + f_frac) #1,2 is prob of going from U to G. dependence on f = edge effects
  P2[2, 3] <- P2[2, 3] + gamma * f_frac #2,3 is prob of going from G to F. increases depending on f_frac
  P2[3, 4] <- P2[3, 4] + psi * (u_frac + r_frac) #3,4 is prob of going from F to R. increases depending on u_frac
  P2[2, 4] <- P2[2, 4] + psi * (u_frac + r_frac) #2,4 is prob of going from G to R. increases depending on u_frac
  P2[3, ] <- P2[3, ] / sum(P2[3, ]) # rescale all transitions from F so they sum to 1.
  P2[2, ] <- P2[2, ] / sum(P2[2, ]) # rescale all transitions from G so they sum to 1.
  P2[1, ] <- P2[1, ] / sum(P2[1, ]) # rescale all transitions from U so they sum to 1.
  P2
}

step_forest <- function(r, alpha, beta, gamma, psi) {
  mf <- neighbor_frac(r, 3) #sum neighbor states that are deforested (state 3)
  mg <- neighbor_frac(r, 2) # ditto for G
  mu <- neighbor_frac(r, 1) #sum neighbor states that are undisturbed (state 1)
  mr <- 1 - mf - mg- mu
  r_new <- r 
  
  for (i in 1:ncell(r)) { #for each cell
    s <- values(r)[i] #get state
    Pi <- modify_P(P, values(mu)[i], values(mg)[i], values(mf)[i], values(mr)[i], alpha, beta, gamma, psi)[s, ]  #get fraction of F neighbors, modify P matrix, extract row s

    values(r_new)[i] <- sample(1:4, 1, prob = Pi) # sample new state based on new P
  }
  
  r_new
}





##################################################################
#### Setup graph labels ####
#
#

forest_cols <- c(
  "#1b7837",  # 1 = Undisturbed (dark green)
  "#90d127",  # 2 = Degraded (light green)
  "#d73027",  # 3 = Deforested (red)
  "#26fd55"   # 4 = Regrown (teal)
)



######################################################################
#### Main loop ####
#
#

r <- r0

png("map_t_series/toy_map_t0.png", width=800, height=800)  # open device
dev.off()
png("map_t_series/toy_map_live.png", width=800, height=800)  # open device
terra::plot(
  r0,
  col = forest_cols,
  type = "classes",
  all_levels = TRUE, 
  main = "Timestep 0",
  axes = FALSE
)
dev.off()     

#store values for plotting
h_values <- c()
alpha_values <- c()
beta_values <- c()
gamma_values <- c()
psi_values <- c()


for (t in 0:tf) {
  cat("Simulating timestep", t, "...\n")

  # calculate time-dependent params based on constants
  h <- (h0 + hpg * t) / h0 # current population relative to initial population.
  alpha <- alpha_h * h + alpha_c * kappa * t
  beta <- beta_h * h + beta_c * kappa * t
  gamma <- gamma_h * h + gamma_c * kappa * t
  psi <- psi_h * h

  # store values for plotting
  h_values <- c(h_values, h)
  alpha_values <- c(alpha_values, alpha)    
  beta_values <- c(beta_values, beta)
  gamma_values <- c(gamma_values, gamma)
  psi_values <- c(psi_values, psi)

  if (t == 0) {
  r <- r0
  } else {
  r <- step_forest(r, alpha, beta, gamma, psi)
  }
  # Ensure levels persist. i dont like this line being here and i wanna take it out later.
  levels(r) <- levels(r0) # i feel like it's gonna slow stuff down.

  
  # Save the timestamped file
  png(glue("map_t_series/toy_map_t{t}.png"), width=800, height=800)
  terra::plot(r, col = forest_cols, type = "classes", all_levels = TRUE, 
              main = glue("Timestep {t}"), axes = FALSE)
  dev.off()
  
  # Save the "live" (latest) file separately
  png("toy_map_live.png", width=800, height=800)
  terra::plot(r, col = forest_cols, type = "classes", all_levels = TRUE, 
              main = glue("Timestep {t}"), axes = FALSE)
  dev.off()
}

t_vector <- 0:tf
# 1. Human Population Growth
png("param_figs/human_population_growth.png", width = 800, height = 600)
plot(t_vector, h_values, type = "o", main = "Human Population Growth", xlab = "Timestep", ylab = "Relative Population")
dev.off()

# 2. Alpha (U->F)
png("param_figs/alpha_values.png", width = 800, height = 600)
plot(t_vector, alpha_values, type = "o", main = "Alpha (U->F)", xlab = "Timestep", ylab = "Alpha Value")
dev.off()

# 3. Beta (U->G)
png("param_figs/beta_values.png", width = 800, height = 600)
plot(t_vector, beta_values, type = "o", main = "Beta (U->G)", xlab = "Timestep", ylab = "Beta Value")
dev.off()

# 4. Gamma (G->F)
png("param_figs/gamma_values.png", width = 800, height = 600)
plot(t_vector, gamma_values, type = "o", main = "Gamma (G->F)", xlab = "Timestep", ylab = "Gamma Value")
dev.off()

# 5. Psi (F->R)
png("param_figs/psi_values.png", width = 800, height = 600)
plot(t_vector, psi_values, type = "o", main = "Psi (F->R)", xlab = "Timestep", ylab = "Psi Value")
dev.off()







